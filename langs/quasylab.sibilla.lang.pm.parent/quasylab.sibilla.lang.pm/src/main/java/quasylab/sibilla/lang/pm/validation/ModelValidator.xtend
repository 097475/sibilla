/*
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.validation

import com.google.inject.Inject
import java.util.function.Function
import java.util.function.Predicate
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.util.IResourceScopeCache
import org.eclipse.xtext.validation.Check
import quasylab.sibilla.lang.pm.model.AndExpression
import quasylab.sibilla.lang.pm.model.CallExpression
import quasylab.sibilla.lang.pm.model.Constant
import quasylab.sibilla.lang.pm.model.Expression
import quasylab.sibilla.lang.pm.model.FractionOf
import quasylab.sibilla.lang.pm.model.IfThenElseExpression
import quasylab.sibilla.lang.pm.model.Macro
import quasylab.sibilla.lang.pm.model.MaxExpression
import quasylab.sibilla.lang.pm.model.MinExpression
import quasylab.sibilla.lang.pm.model.ModelPackage
import quasylab.sibilla.lang.pm.model.ModuloExpression
import quasylab.sibilla.lang.pm.model.MulDivExpression
import quasylab.sibilla.lang.pm.model.Multiplicity
import quasylab.sibilla.lang.pm.model.NegationExpression
import quasylab.sibilla.lang.pm.model.NotExpression
import quasylab.sibilla.lang.pm.model.NumberOf
import quasylab.sibilla.lang.pm.model.OrExpression
import quasylab.sibilla.lang.pm.model.RelationExpression
import quasylab.sibilla.lang.pm.model.Rule
import quasylab.sibilla.lang.pm.model.SumDiffExpression

import static extension org.eclipse.xtext.EcoreUtil2.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ModelValidator extends AbstractModelValidator {
	
	protected static val ISSUE_CODE_PREFIX = "quasylab.sibilla.lang.pm."
	
	public static val RECURSIVE_DECLARATION = ISSUE_CODE_PREFIX+"RecursiveDeclaration"
	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
	
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX+"IncompatibleType"	
		
	public static val ILLEGAL_POPULATION_EXPRESSION = ISSUE_CODE_PREFIX+"IllegalPopulationExpression"	
		
	public static val ILLEGAL_POPULATION_EXPRESSION_MESSAGE = "Illegal use of population expressions!"	
		
	@Inject extension ExpressionTypeInference
	
	@Inject IResourceScopeCache cache = IResourceScopeCache.NullImpl.INSTANCE
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					ModelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check 
	def checkBooleanInOr( OrExpression e ) {
		checkExpectedBoolean(e.left ,ModelPackage.eINSTANCE.orExpression_Left);
		checkExpectedBoolean(e.right ,ModelPackage.eINSTANCE.orExpression_Right);
	}

	@Check 
	def checkBooleanInAnd( AndExpression e ) {
		checkExpectedBoolean(e.left ,ModelPackage.eINSTANCE.andExpression_Left);
		checkExpectedBoolean(e.right ,ModelPackage.eINSTANCE.andExpression_Right);
	}

	@Check 
	def checkNumbersInRelations( RelationExpression e ) {
		checkExpectedNumber(e.left ,ModelPackage.eINSTANCE.relationExpression_Left);
		checkExpectedNumber(e.right ,ModelPackage.eINSTANCE.relationExpression_Right);
	}

	@Check 
	def checkIntegerInModulo( ModuloExpression e ) {
		checkExpectedInteger(e.left ,ModelPackage.eINSTANCE.moduloExpression_Left);
		checkExpectedInteger(e.right ,ModelPackage.eINSTANCE.moduloExpression_Right);
	}
	
	@Check 
	def checkNumbersInMulDiv( MulDivExpression e ) {
		checkExpectedNumber(e.left ,ModelPackage.eINSTANCE.mulDivExpression_Left);
		checkExpectedNumber(e.right ,ModelPackage.eINSTANCE.mulDivExpression_Right);
	}
	
	@Check 
	def checkNumbersInSumDiff( SumDiffExpression e ) {
		checkExpectedNumber(e.left ,ModelPackage.eINSTANCE.sumDiffExpression_Left);
		checkExpectedNumber(e.right ,ModelPackage.eINSTANCE.sumDiffExpression_Right);
	}

	@Check 
	def checkBooleanInNot( NotExpression e ) {
		checkExpectedBoolean(e.argument, ModelPackage.eINSTANCE.notExpression_Argument);
	}

	@Check 
	def checkIfThenElseExpression( IfThenElseExpression e ) {
		checkExpectedBoolean(e.guard, ModelPackage.eINSTANCE.ifThenElseExpression_Guard);
		val tLeft = e.ifBranch ?. inferType ?: ExpressionType::ERROR 
		if (tLeft != ExpressionType::ERROR) {
			val tRight = e.elseBranch ?. inferType ?: ExpressionType::ERROR 
			if ((tRight != ExpressionType::ERROR)&&(ExpressionTypeInference.combine(tLeft, tRight) == ExpressionType::ERROR )) {
				error(incompatibleTypesMessage(tLeft,tRight),ModelPackage.eINSTANCE.ifThenElseExpression_ElseBranch,INCOMPATIBLE_TYPES);		
			}
		} 
	}

	@Check 
	def checkNumberInNegation( NegationExpression e ) {
		checkExpectedNumber(e.argument, ModelPackage.eINSTANCE.negationExpression_Argument);
	}

	@Check 
	def checkNumberInMin( MinExpression e ) {
		e.args.forEach[arg, i|
			checkExpectedNumber(arg, ModelPackage.eINSTANCE.minExpression_Args,i);
		]
	}

	@Check 
	def checkNumberInMin( MaxExpression e ) {
		e.args.forEach[arg, i|
			checkExpectedNumber(arg, ModelPackage.eINSTANCE.maxExpression_Args,i);
		]
	}
	
	@Check 
	def checkGuardRule( Rule e ) {
		if (e.guard !== null) {
			checkExpectedBoolean(e.guard, ModelPackage.eINSTANCE.rule_Guard);			
		}
	}

	@Check 
	def checkRateRule( Rule e ) {
		checkExpectedNumber(e.rate, ModelPackage.eINSTANCE.rule_Rate);			
	}
	
	@Check
	def checkIntegerMultiplicity( Multiplicity m ) {
		checkExpectedInteger(m.size,ModelPackage.eINSTANCE.multiplicity_Size);
	}
	
	@Check
	def checkPopulationFraction( FractionOf f ) {
		if (!dynamicContext(f)) {
			error(ILLEGAL_POPULATION_EXPRESSION_MESSAGE,ModelPackage.eINSTANCE.fractionOf_Agent,ILLEGAL_POPULATION_EXPRESSION)
		}
	}
		
	def dynamicContext(Expression  e) {
		val rule = e.getContainerOfType(Rule)
		val macro = e.getContainerOfType(Macro)
		(rule !== null)||(macro !== null)
	}

	@Check
	def checkPopulationFraction( NumberOf f ) {
		if (!dynamicContext(f)) {
			error(ILLEGAL_POPULATION_EXPRESSION_MESSAGE,ModelPackage.eINSTANCE.numberOf_Agent,ILLEGAL_POPULATION_EXPRESSION)
		}
	}

	@Check
	def checkCallOfMacro( CallExpression c ) {
		if (c.symbol instanceof Macro) {
			if (!dynamicContext(c)) {
				error(ILLEGAL_POPULATION_EXPRESSION_MESSAGE,ModelPackage.eINSTANCE.callExpression_Symbol,ILLEGAL_POPULATION_EXPRESSION)
			}
		}
	}
	
	@Check
	def checkNoConstantRecursion( Constant c ) {
		val usedConstants = newHashSet()
		val toVisitConstants = newLinkedList
		c.allUsedConstants.forEach[toVisitConstants.add(it)]
		while (!toVisitConstants.empty) {
			val c1 = toVisitConstants.poll
			usedConstants.add(c1)
			c1.allUsedConstants.filter[!usedConstants.contains(it)].forEach[toVisitConstants.add(it)]
		}
		if (usedConstants.contains(c)) {
			error(
				recursiveDeclarationMessage(c.name),				
				ModelPackage.eINSTANCE.constant_Value,
				RECURSIVE_DECLARATION				
			)
		}
	}

	@Check
	def checkNoMacroRecursion( Macro m ) {
		val usedConstants = newHashSet()
		val toVisitConstants = newLinkedList
		m.allUsedMacros.forEach[toVisitConstants.add(it)]
		while (!toVisitConstants.empty) {
			val m1 = toVisitConstants.poll
			usedConstants.add(m1)
			m1.allUsedMacros.filter[!usedConstants.contains(it)].forEach[toVisitConstants.add(it)]
		}
		if (usedConstants.contains(m)) {
			error(
				recursiveDeclarationMessage(m.name),				
				ModelPackage.eINSTANCE.macro_Value,
				RECURSIVE_DECLARATION				
			)
		}
	}

	def getAllUsedConstants( Constant c ) {
		c.eAllContents
			.filter(CallExpression)
			.map[it.symbol]
			.filter(Constant)
	}
	
	def getAllUsedMacros( Macro m ) {
		m.eAllContents
			.filter(CallExpression)
			.map[it.symbol]
			.filter(Macro)
	}

//	@Check
//	def checkNoRecursionAmongSymbols( OrExpression e ) {
//		checkExpectedBoolean(e.left,ModelPackage.eINSTANCE.orExpression_Left)
//		checkExpectedBoolean(e.right,ModelPackage.eINSTANCE.orExpression_Right)
//	}
	
	def private checkExpectedBoolean(Expression e, EReference reference) {
		checkExpectedType(e,ExpressionType::BOOLEAN,reference)				
	}

	def private checkExpectedInteger(Expression e, EReference reference) {
		checkExpectedType(e,ExpressionType::INTEGER,reference)				
	}

	def private checkExpectedDouble(Expression e, EReference reference) {
		checkExpectedType(e,ExpressionType::DOUBLE,reference)				
	}

	def private checkExpectedNumber(Expression e, EReference reference) {
		checkExpectedType(e,[t|ModelValidator.numberTypeExpected(t)],[t|t.isANumberType],reference)				
	}

	def private checkExpectedNumber(Expression e, EReference reference,int index) {
		checkExpectedType(e,[t|ModelValidator.numberTypeExpected(t)],[t|t.isANumberType],reference,index)				
	}

	def private checkExpectedType(Expression e, ExpressionType expectedType, EReference reference) {
		checkExpectedType(e,[t|wrongExpectedTypeMessage(expectedType,t)],[t|t==expectedType],reference)
	}

	
	def private checkExpectedType(Expression e, Function<ExpressionType,String> msg, Predicate<ExpressionType> p, EReference reference) {
		val actualType = e ?. inferType 
		if ((actualType !== null)&&(actualType != ExpressionType::ERROR)&&(!p.test(actualType))) {
			error(msg.apply(actualType),reference,TYPE_MISMATCH);	
		}
	}

	def private checkExpectedType(Expression e, Function<ExpressionType,String> msg, Predicate<ExpressionType> p, EReference reference, int index) {
		val actualType = e ?. inferType 
		if ((actualType !== null)&&(actualType != ExpressionType::ERROR)&&(!p.test(actualType))) {
			error(msg.apply(actualType),reference,index,TYPE_MISMATCH);	
		}
	}

	def static incompatibleTypesMessage(ExpressionType expected, ExpressionType actual) {
		 "Incompatible types: expected "+expected+" is "+actual+"."
	}
		
	def static numberTypeExpected(ExpressionType actual) {
		"Expected "+ExpressionType::INTEGER+" or "+ExpressionType::DOUBLE+" but it is "+actual+"."
	}

	def static wrongExpectedTypeMessage(ExpressionType expected,  ExpressionType actual) {
		"Expected "+expected+" but it is "+actual+"."
	}
		
	def static booleanTypeExpected(ExpressionType actual) {
		"Expected "+ExpressionType::BOOLEAN+" but it is "+actual+"."
	}
		
	def static integerTypeExpected(ExpressionType actual) {
		"Expected "+ExpressionType::INTEGER+" but it is "+actual+"."
	}
		
	def static recursiveDeclarationMessage(String symbol) {
		"Cycle in definition of symbol"+symbol+"!"
	}
	
		
}
