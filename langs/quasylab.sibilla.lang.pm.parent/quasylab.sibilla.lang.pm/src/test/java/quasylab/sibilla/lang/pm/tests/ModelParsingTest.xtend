/*
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import quasylab.sibilla.lang.pm.model.Constant
import quasylab.sibilla.lang.pm.model.Model

@ExtendWith(InjectionExtension)
@InjectWith(ModelInjectorProvider)
class ModelParsingTest {
	
	@Inject extension ParseHelper<Model>
	
	@Inject extension ValidationTestHelper
	
	@Test
	def void typeChecker() {
		'''
			const A = 0.1;
			const B = true;
			const C = 10;
			
			const D = A+C;
					
		'''.parse.assertNoErrors
		
//		Assertions.assertNotNull(result)
//		val errors = result.eResource.errors
//		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
		
//		val tInference = new ExpressionTypeInference();
//		tInference.inferTypes(result)
//		Assertions.assertEquals(ExpressionType::DOUBLE,result.getConstant("A").typeOf,'''Wrong type for A''')
//		Assertions.assertEquals(ExpressionType::BOOLEAN,result.getConstant("B").typeOf,'''Wrong type for B''')
//		Assertions.assertEquals(ExpressionType::INTEGER,result.getConstant("C").typeOf,'''Wrong type for C''')
//		Assertions.assertEquals(ExpressionType::DOUBLE,result.getConstant("D").typeOf,'''Wrong type for D''')
		
		
	}
	
	def getConstant(Model m, String name) {
		m.elements.filter(Constant).findFirst[it.name.equals(name)]
	}
	
	@Test
	def void loadModel() {
		'''
			species GA;			
			species CA;
			species GB;
			species CB;
			
			macro meetrate = 1.0;

			
			rule groupyA = GA -[ %CB*meetrate ]-> GB; 
			rule groupyB = GB -[ %CA*meetrate ]-> GA;
			rule celebrityA = CA -[ (%CA+%GA)*meetrate ]-> CB;
			rule celebrityB = CB -[ (%CB+%GB)*meetrate ]-> CA;

		'''.parse.assertNoErrors
	}
}
