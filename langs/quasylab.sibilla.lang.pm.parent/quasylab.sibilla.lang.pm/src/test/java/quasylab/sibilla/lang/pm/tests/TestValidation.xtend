/*
 * generated by Xtext 2.17.0
 */
package quasylab.sibilla.lang.pm.tests

import com.google.inject.Inject
import org.eclipse.emf.ecore.EClass
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import quasylab.sibilla.lang.pm.model.Model
import quasylab.sibilla.lang.pm.model.ModelPackage
import quasylab.sibilla.lang.pm.validation.ExpressionType
import quasylab.sibilla.lang.pm.validation.ModelValidator

@ExtendWith(InjectionExtension)
@InjectWith(ModelInjectorProvider)
class TestValidation {
	
	@Inject extension ParseHelper<Model>
	
	@Inject extension ValidationTestHelper
	
	@Test
	def void relationNoNumberTypeLeft() {
		'''const test = true<10;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.relationExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void relationNoNumberTypeRight() {
		'''const test = 10<true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.relationExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void relationNoNumberTypeLeftRight() {
		'''const test = false<true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.relationExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void orWrongLeftType() {
		'''const test = 1||false;'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.orExpression,ExpressionType::INTEGER)
		
	}

	@Test
	def void orWrongRightType() {
		'''const test = false||1;'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.orExpression,ExpressionType::INTEGER)
		
	}

	@Test
	def void andWrongLeftType() {
		'''const test = 1&&false;'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.andExpression,ExpressionType::INTEGER)
		
	}

	@Test
	def void andWrongRightType() {
		'''const test = false&&1;'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.andExpression,ExpressionType::INTEGER)
		
	}
	
	@Test
	def void moduloWrongLeftType() {
		'''const test = 1%false;'''
			.parse.assertNoInteger(ModelPackage.eINSTANCE.moduloExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void moduloWrongRightType() {
		'''const test = false%1;'''
			.parse.assertNoInteger(ModelPackage.eINSTANCE.moduloExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void divNoNumberTypeRight() {
		'''const test = 10/true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.mulDivExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void divNoNumberTypeLeft() {
		'''const test = false/10;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.mulDivExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void mulNoNumberTypeRight() {
		'''const test = 10*true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.mulDivExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void mulNoNumberTypeLeft() {
		'''const test = false*10;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.mulDivExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void sumNoNumberTypeRight() {
		'''const test = 10+true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.sumDiffExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void sumNoNumberTypeLeft() {
		'''const test = false+10;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.sumDiffExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void diffNoNumberTypeRight() {
		'''const test = 10-true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.sumDiffExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void diffNoNumberTypeLeft() {
		'''const test = false-10;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.sumDiffExpression,ExpressionType::BOOLEAN)
		
	}
	
	@Test
	def void notWrongArgumentType() {
		'''const test = !1;'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.notExpression,ExpressionType::INTEGER)
		
	}

	@Test
	def void ifThenElseWrongGuardType() {
		'''const test = (1?1:2);'''
			.parse.assertNoBoolean(ModelPackage.eINSTANCE.ifThenElseExpression,ExpressionType::INTEGER)
		
	}
	
	@Test
	def void ifThenElseUncompatibleTypes() {
		'''const test = (true?true:2);'''
			.parse.assertIncompatibleType(ModelPackage.eINSTANCE.ifThenElseExpression,ExpressionType::BOOLEAN,ExpressionType::INTEGER)
		
	}

	@Test
	def void negationWrongArgumentType() {
		'''const test = -true;'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.negationExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void minWrongArgumentType() {
		'''const test = min( 1 , true );'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.minExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void maxWrongArgumentType() {
		'''const test = max( 1 , true );'''
			.parse.assertNotNumber(ModelPackage.eINSTANCE.maxExpression,ExpressionType::BOOLEAN)
		
	}

	@Test
	def void ruleGuardWrongType() {
		'''
		species A;
		species B;
		
		rule test[1] = A|B -[ 1.0 ]-> A|A;
		'''.parse.assertNoBoolean(ModelPackage.eINSTANCE.rule,ExpressionType::INTEGER)
	}

	@Test
	def void ruleRateWrongType() {
		'''
		species A;
		species B;
		
		rule test = A|B -[ true ]-> A|A;
		'''.parse.assertNotNumber(ModelPackage.eINSTANCE.rule,ExpressionType::BOOLEAN)
	}

	@Test
	def void multiplicitySizeWrongType() {
		'''
		species A;
		species B;
		
		rule test = A[true] -[ 1.0 ]-> B;
		'''.parse.assertNoInteger(ModelPackage.eINSTANCE.multiplicity,ExpressionType::BOOLEAN)
	}

	@Test
	def void dynamicFractionExpressionInConstant() {
		'''
		species A;
		species B;
		
		const test = %A;
		'''.parse.assertError(ModelPackage.eINSTANCE.fractionOf,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE
		)
	}

	@Test
	def void dynamicCouningExpressionInConstant() {
		'''
		species A;
		species B;
		
		const test = #A;
		'''.parse.assertError(ModelPackage.eINSTANCE.numberOf,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE
		)
	}

	@Test
	def void macroWithCountingExpression() {
		'''
		species A;
		species B;
		
		macro test = #A;
		'''.parse.assertNoErrors
	}

	@Test
	def void macroWithFractionExpression() {
		'''
		species A;
		species B;
		
		macro test = %A;
		'''.parse.assertNoErrors
	}
	
	@Test
	def void noMacroInConstant() {
		'''
		species A;
		species B;
		
		macro aMacro = #A;
		const test = aMacro;
		'''.parse.assertError(ModelPackage.eINSTANCE.callExpression,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION,
				ModelValidator.ILLEGAL_POPULATION_EXPRESSION_MESSAGE
		)
	}
	
	@Test
	def void correctConstReference() {
		'''
		species A;
		species B;
		
		const const1 = 1;
		const const2 = const1+1;
		'''.parse.assertNoErrors
	}
	
	@Test
	def  void testRecursiveConstants() {
		'''
		const constA = constB;
		const constB = constC;
		const constC = constA;
		'''.parse.assertError(
			ModelPackage.eINSTANCE.constant,
			ModelValidator.RECURSIVE_DECLARATION,
			ModelValidator.recursiveDeclarationMessage("constA")
		)
	}

	@Test
	def  void testNoRecursiveConstants() {
		'''
		const constA = constB;
		const constB = constC;
		const constC = 1.0;
		'''.parse.assertNoErrors
	}
	
	@Test
	def  void testRecursiveMacros() {
		'''
		macro macroA = macroB;
		macro macroB = macroC;
		macro macroC = macroA;
		'''.parse.assertError(
			ModelPackage.eINSTANCE.macro,
			ModelValidator.RECURSIVE_DECLARATION,
			ModelValidator.recursiveDeclarationMessage("macroA")
		)
	}

	@Test
	def  void testNoRecursiveMacros() {
		'''
		macro macroA = macroB;
		macro macroB = macroC;
		macro macroC = 1.0;
		'''.parse.assertNoErrors
	}
	
	

	def private assertIncompatibleType( Model m , EClass objectType,  ExpressionType exptected, ExpressionType actual ) {
		m.assertError(objectType,ModelValidator.INCOMPATIBLE_TYPES,ModelValidator.incompatibleTypesMessage(exptected,actual));
	}
	
	def private assertNotNumber( Model m , EClass objectType,  ExpressionType actual) {
		m.assertError(objectType,ModelValidator.TYPE_MISMATCH,ModelValidator.numberTypeExpected(actual));
	}
	
	def private assertNoBoolean( Model m , EClass objectType,  ExpressionType actual) {
		m.assertError(objectType,ModelValidator.TYPE_MISMATCH,ModelValidator.booleanTypeExpected(actual));
	}

	def private assertNoInteger( Model m , EClass objectType,  ExpressionType actual) {
		m.assertError(objectType,ModelValidator.TYPE_MISMATCH,ModelValidator.integerTypeExpected(actual));
	}
	

}
